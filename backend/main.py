from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import sys
import os
import logging

# ensure project root is on path
ROOT = os.path.dirname(os.path.dirname(__file__))
sys.path.insert(0, ROOT)

logger = logging.getLogger("uvicorn")

app = FastAPI(title="AI Cyber Threat Forecaster API")

# Allow local frontend during development
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],
    allow_methods=["*"],
    allow_headers=["*"],
)


class Threat(BaseModel):
    id: str
    title: str
    severity: str
    timestamp: str
    summary: str
    description: Optional[str]
    source: Optional[str]
    indicators: Optional[List[str]] = []
    affectedSystems: Optional[List[str]] = []
    recommendation: Optional[str] = None


@app.get("/api/health")
async def health():
    return {"status": "ok"}


@app.get("/api/stats")
async def get_stats():
    # Try to compute from data_layer or fallback to sample
    try:
        from data_layer.timeseries_db import get_overview_metrics_api
        
        stats = get_overview_metrics_api()
        return stats
    except Exception as e:
        logger.warning("timeseries DB access failed, returning fallback stats: %s", e)
        return {
            "totalThreats": 2847,
            "criticalThreats": 12,
            "activeCampaigns": 34,
            "lastUpdate": None,
        }


@app.get("/api/threats")
async def list_threats(page: int = 1, limit: int = 10):
    try:
        from data_layer.neo4j_connector import query_threats_api
        
        threats, total = query_threats_api(page=page, limit=limit)
        return {"threats": threats, "total": total}
    except Exception as e:
        logger.warning("Neo4j query failed, returning fallback threats: %s", e)
        # fallback: create simple mock threats
        sample = []
        for i in range((page - 1) * limit, (page - 1) * limit + limit):
            sample.append(
                {
                    "id": str(i + 1),
                    "title": f"Synthetic Threat {i + 1}",
                    "severity": "medium",
                    "timestamp": None,
                    "summary": "Generated fallback threat",
                    "description": "This is a fallback generated by API",
                    "source": "fallback",
                    "indicators": [],
                    "affectedSystems": [],
                    "recommendation": "Investigate and enrich data",
                }
            )
        return {"threats": sample, "total": 1000}


@app.get("/api/threats/{threat_id}")
async def get_threat(threat_id: str):
    try:
        from data_layer.neo4j_connector import get_threat_by_id_api
        
        t = get_threat_by_id_api(threat_id)
        if not t:
            raise HTTPException(status_code=404, detail="Threat not found")
        return t
    except HTTPException:
        raise
    except Exception as e:
        logger.warning("Failed to retrieve threat from Neo4j: %s", e)
        # fallback simple response
        return {
            "id": threat_id,
            "title": "Fallback Threat",
            "severity": "low",
            "timestamp": None,
            "summary": "Fallback detail",
            "description": "No DB available",
            "indicators": [],
            "affectedSystems": [],
            "recommendation": "No-op",
        }


@app.post("/api/crawler/start")
async def start_crawler():
    # Try to import a crawler orchestration if present, else simulate
    try:
        from scripts.crawler_orchestrator import run_crawler

        logs = run_crawler()
        return {"logs": logs}
    except Exception as e:
        logger.warning("Crawler orchestrator missing, returning simulated logs: %s", e)
        logs = []
        for i in range(10):
            logs.append({"timestamp": None, "message": f"Simulated log {i}", "type": "info"})
        return {"logs": logs}


@app.get("/api/search")
async def search(q: str):
    # naive search on Neo4j or fallback to in-memory
    try:
        from data_layer.neo4j_connector import search_threats_api
        
        results = search_threats_api(q)
        return {"results": results}
    except Exception as e:
        logger.warning("Search failed, fallback: %s", e)
        return {"results": []}


if __name__ == "__main__":
    import uvicorn

    uvicorn.run("backend.main:app", host="0.0.0.0", port=8000, reload=True)
